>include "example_source/tetris/blocks.f12";

char[] input_buff = new char[15];

char[][] board;

char[][][] falling_block_type;
char[][] falling_block;
int falling_block_corner_x;
int falling_block_corner_y;


fun init_board {
    board = new char[][BOARD_HEIGHT];

    int row = 0;
    while row < BOARD_HEIGHT {
        board[row] = new char[BOARD_WIDTH];

        int column = 0;
        while column < BOARD_WIDTH {
            board[row][column] = determine_char(column, row);
            column = column + 1;
        }

        row = row + 1;
    }

    reset_falling_block();
}

fun print_board {
    int row = 0;
    while row < BOARD_HEIGHT {
        int column = 0;
        while column < BOARD_WIDTH {
            put_char_x_y(board[row][column], column, row + TOP_OFFSET);
            column = column + 1;
        }

        row = row + 1;
    }
}

fun process_frame {
    paint_falling_block(BACKGROUND_CHAR);

    int chars_read = get_input(input_buff);
    process_input(chars_read);

    if will_block_collide(0, 1) {
        paint_falling_block(BLOCK_CHAR);
        reset_falling_block();
        paint_falling_block(BLOCK_CHAR);
    } else {
        falling_block_corner_y = falling_block_corner_y + 1;
    }

    paint_falling_block(BLOCK_CHAR);
}

fun process_input(int chars_read) {
    int i = 0;
    while i < chars_read {
        char c = input_buff[i];
        int x = falling_block_corner_x;
        int y = falling_block_corner_y;

        if c == MOVE_LEFT && !will_block_collide(-1, 0) {
            falling_block_corner_x = falling_block_corner_x - 1;
        }

        if c == MOVE_RIGHT && !will_block_collide(1, 0) {
            falling_block_corner_x = falling_block_corner_x + 1;
        }

        if c == MOVE_DOWN && !will_block_collide(0, +1) {
            falling_block_corner_y = falling_block_corner_y + 1;
        }

        if c == ROTATE {
            falling_block = rotate_block(falling_block_type);
        }

        i = i + 1;
    }
}

fun will_block_collide(int dx, int dy) => bool {
    int row = 0;
    while row < BLOCK_MAX_ROWS {
        int column = 0;
        while column < BLOCK_MAX_COLUMNS {
            if falling_block[row][column] == BLOCK_CHAR {
                if will_point_collide(falling_block_corner_x + column + dx, falling_block_corner_y + row + dy) {
                    ret true;
                }
            }

            column = column + 1;
        }

        row = row + 1;
    }

    ret false;
}

fun will_point_collide(int x, int y) => bool {
    if x <= LEFT_WALL || x >= RIGHT_WALL || y >= FLOOR {
        ret true;
    }

    ret board[y][x] != BACKGROUND_CHAR;
}

fun paint_falling_block(char c) {
    int row = 0;
    while row < BLOCK_MAX_ROWS {
        int column = 0;
        while column < BLOCK_MAX_COLUMNS {
            if falling_block[row][column] == BLOCK_CHAR {
                board[falling_block_corner_y + row][falling_block_corner_x + column] = c;
            }

            column = column + 1;
        }

        row = row + 1;
    }
}

fun reset_falling_block {
    falling_block_corner_x = BOARD_WIDTH / 2;
    falling_block_corner_y = 0;

    falling_block_type = get_next_block_type();
    falling_block = rotate_block(falling_block_type);
}

fun determine_char(int column, int row) => char {
    if is_wall(column, row) {
        ret WALL_CHAR;
    }

    if is_floor(column, row) {
        ret FLOOR_CHAR;
    }

    ret BACKGROUND_CHAR;
}

fun is_wall(int x, int y) => bool {
    if y == BOARD_HEIGHT {
        ret false;
    }

    ret x == LEFT_WALL || x == RIGHT_WALL;
}

fun is_floor(int x, int y) => bool {
    ret y == FLOOR;
}